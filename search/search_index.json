{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"C++ codes","text":""},{"location":"00-basics/01-struct-and-enums/01-enum/","title":"Enums (Enumeration)","text":"<ul> <li>if you have a finite set of values, use an enum instead of using a number and remembering what each number means</li> <li>for example, if you have a set of days of the week, you can use an enum to represent that, instead of using numbers from (0-6)</li> <li>enums are a type of data structure that is used to define a set of named constants</li> </ul>"},{"location":"00-basics/01-struct-and-enums/01-enum/#simple-code","title":"Simple Code","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nenum LogLevel : unsigned int // define datatype (can be any integer type)\n{\n    DEBUG, // 0\n    ERROR, // 1\n    INFO,  // 2\n    WARNING // 3\n};\n\nint main()\n{\n    LogLevel level = DEBUG;\n    cout &lt;&lt; level &lt;&lt; endl;\n\n    LogLevel level2 = LogLevel::INFO;\n\n    cout &lt;&lt; level2 &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"00-basics/01-struct-and-enums/01-enum/#change-enum-values","title":"Change Enum values","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nenum Level {\n  LOW = 25,\n  MEDIUM = 50,\n  HIGH = 75\n};\n\nint main()\n{\n    LogLevel level = DEBUG;\n    cout &lt;&lt; level &lt;&lt; endl;\n\n    LogLevel level2 = LogLevel::INFO;\n\n    cout &lt;&lt; level2 &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"00-basics/01-struct-and-enums/01-enum/#change-enum-starting-value","title":"Change Enum <code>starting value</code>","text":"<ul> <li>if we assign a value to one specific item, the next items will update their numbers accordingly:</li> </ul> <pre><code>enum Level {\n  LOW = 5,\n  MEDIUM, // Now 6\n  HIGH // Now 7\n};\n</code></pre>"},{"location":"00-basics/01-struct-and-enums/01-enum/#enum-in-switch","title":"Enum in Switch","text":"<pre><code>enum Level {\n  LOW = 1,\n  MEDIUM,\n  HIGH\n};\n\nint main() {\n  enum Level myVar = MEDIUM;\n\n  switch (myVar) {\n    case 1:\n      cout &lt;&lt; \"Low Level\";\n      break;\n    case 2:\n      cout &lt;&lt; \"Medium level\";\n      break;\n    case 3:\n      cout &lt;&lt; \"High level\";\n      break;\n  }\n\n  cout &lt;&lt; \"===========================\\n\";\n\n  switch (myVar) {\n    case LOW:\n      cout &lt;&lt; \"Low Level\";\n      break;\n    case MEDIUM:\n      cout &lt;&lt; \"Medium level\";\n      break;\n    case HIGH:\n      cout &lt;&lt; \"High level\";\n      break;\n  }\n\n  cout&lt;&lt;\"\\n\";\n  return 0;\n}\n</code></pre>"},{"location":"00-basics/01-struct-and-enums/02-struct/","title":"Structs","text":"<ul> <li>structs are a way to group related data together</li> <li>they are useful when you want to create a custom data type that has multiple fields</li> <li>structs are defined using the <code>struct</code> keyword</li> </ul> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nstruct Point {\n  int x;\n  int y;\n};\n\nint main() {\n  Point p1 = {1, 2}; // method: 1\n  Point p2 = {.x = 3, .y = 4}; // method: 2\n  cout &lt;&lt; p1.x &lt;&lt; \" \" &lt;&lt; p1.y &lt;&lt; endl;\n  cout &lt;&lt; p2.x &lt;&lt; \" \" &lt;&lt; p2.y &lt;&lt; endl;\n  return 0;\n}\n</code></pre> <ul> <li> <p>Both ways of instantiating a struct are correct in C++.  </p> </li> <li> <p><code>Point p1 = {1, 2};</code></p> <ul> <li>This is aggregate initialization, which initializes struct members in order.  </li> <li>Works in both C and C++.</li> </ul> </li> <li> <p><code>Point p2 = {.x = 3, .y = 4};</code> </p> <ul> <li>This is designated initialization, which allows initializing specific members explicitly.  </li> <li>C++20 and later only (not valid in C++17 or earlier).  </li> </ul> </li> </ul> <p>If you're using C++17 or older, <code>p2</code> will cause a compilation error.</p>"},{"location":"00-basics/01-struct-and-enums/02-struct/#functions-in-structs","title":"Functions in Structs","text":"<ul> <li>functions can be defined inside structs</li> <li>they can be used to access the fields of the struct</li> <li>functions can be defined with the <code>static</code> keyword to make them accessible <code>without creating struct variable</code>.</li> </ul> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\nstruct Point\n{\n    int x;\n    int y;\n\n    void init(int x, int y){\n        this-&gt;x = x;\n        this-&gt;y = y;\n    }\n    static int getX(Point p)\n    {\n        return p.x;\n    }\n\n    static double getPi()\n    {\n        return 3.1415;\n    }\n};\n\nint main()\n{\n    Point p;\n    p.init(1, 2);\n    cout &lt;&lt; Point::getX(p) &lt;&lt; endl;\n    return 0;\n}\n</code></pre>"},{"location":"00-basics/01-struct-and-enums/02-struct/#constructor-and-destructor-in-structs","title":"Constructor and Destructor in Structs","text":"<ul> <li>constructors and destructors are special functions that are called when an object is created and destroyed, respectively</li> <li>they are defined inside the struct</li> <li>Constructors =&gt; Same name as the struct</li> <li>Destructors =&gt; Same name as the struct, but with an extra <code>~</code> at the start</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;cmath&gt;\nusing namespace std;\n\nstruct Point\n{\n    int x;\n    int y;\n    Point(int x, int y) : x(x), y(y) {\n        cout &lt;&lt; \"constructor called\" &lt;&lt; endl;\n    }\n    ~Point() {\n        cout &lt;&lt; \"destructor called\" &lt;&lt; endl;\n    }\n\n    void distanceFromOrigin() {\n        cout &lt;&lt; \"distance from origin: \" &lt;&lt; sqrt(x * x + y * y) &lt;&lt; endl;\n    }\n};\n\nint main()\n{\n    Point p(1, 2);\n    p.distanceFromOrigin();\n    return 0;\n}\n</code></pre>"},{"location":"00-basics/01-struct-and-enums/02-struct/#initializer-list","title":"Initializer List","text":"<ul> <li>initializer lists are a way to initialize the fields of a struct</li> <li>they are defined using the <code>:</code> operator</li> <li>they are useful to separate the initialization code from the main constructor body to help developers focus on what special functionality the constructor provides rather than the boilerplate code</li> </ul> <pre><code>struct Point\n{\n    int x;\n    int y;\n\n    // below `: x(x), y(y)` is the initializer list\n\n    Point(int x, int y) : x(x), y(y) {}\n};\n</code></pre>"},{"location":"00-basics/01-struct-and-enums/02-struct/#creating-instances-of-structs-with-struct-declarations","title":"Creating instances of Structs with Struct declarations","text":"<pre><code>struct Point\n{\n    int x;\n    int y;\n\n    // below `: x(x), y(y)` is the initializer list\n    Point(int x, int y) : x(x), y(y) {}\n\n}p1(1,2), p2(3,4);\n// p1 and p2 are instances of the Point struct\n</code></pre>"},{"location":"00-basics/02-functions/01-intro/","title":"Functions in C++","text":""},{"location":"00-basics/02-functions/01-intro/#simple-example","title":"Simple Example","text":"<pre><code>#include &lt;iostream&gt;\n\nstd::string greet(std::string x){\n    return \"Hello, \" + x + \"!\";\n}\n\nint main(){\n    std::cout&lt;&lt;greet(\"Deep\")&lt;&lt;\"\\n\";\n}\n</code></pre>"},{"location":"00-basics/02-functions/01-intro/#function-overloading","title":"Function overloading","text":"<ul> <li>multiple functions can have the same name with different parameters.</li> </ul> <pre><code>int plusFuncInt(int x, int y) {\n  return x + y;\n}\n\ndouble plusFuncDouble(double x, double y) {\n  return x + y;\n}\n\nint main() {\n  int myNum1 = plusFuncInt(8, 5);\n  double myNum2 = plusFuncDouble(4.3, 6.26);\n  cout &lt;&lt; \"Int: \" &lt;&lt; myNum1 &lt;&lt; \"\\n\";\n  cout &lt;&lt; \"Double: \" &lt;&lt; myNum2;\n  return 0;\n}\n</code></pre> <p>Danger</p> <ul> <li>You can't overload a function with same name, same parameter numbers and type, but different return type.</li> </ul> <p>Function overloading compile-time V/S Runtime performance</p> <ul> <li><code>Function Overloading</code> requires the compiler to perform name mangling on the function name to include information about the argument types.</li> </ul> <p>name mangling: modifying name (<code>List_my.get</code> -&gt; <code>List__my_get</code>)</p> <ul> <li>Since, name mangling is done at compile-time, so compile time increases.</li> <li>But, during runtime, function (with mangled name) is called directly, so no performance penalty.</li> </ul>"},{"location":"00-basics/02-functions/01-intro/#function-overloading-vs-overriding","title":"Function Overloading V/S Overriding","text":"<ul> <li><code>function overloading</code> means having multiple functions with same name, but different parameter count or types.</li> <li><code>function/method overriding</code> is when we override a base/default method present in base class in an inherited derived class.</li> </ul>"},{"location":"00-basics/02-functions/02-function-pointers/","title":"Function Pointers","text":"<ul> <li>Function pointers are a way to store a reference to a function.</li> <li>They are useful when you want to pass a function as an argument to another function.</li> </ul> <pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\nint add(int a, int b)\n{\n    return a + b;\n}\n\nint main()\n{\n    auto my_add = add;\n    // auto ==&gt; int (*my_add)(int, int)\n    // int (*my_add)(int, int) = add;\n\n    cout &lt;&lt; my_add(2, 3) &lt;&lt; endl;\n    return 0;\n}\n</code></pre> <ul> <li>Mostly, <code>auto</code> keyword is used to infer the type of the function pointer.</li> <li>In the above example, the type of the function pointer is <code>int (*)(int, int)</code>.</li> </ul>"},{"location":"00-basics/02-functions/02-function-pointers/#passing-a-function-pointer-as-an-argument","title":"Passing a function pointer as an argument","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid forEach(vector&lt;int&gt; v, void (*f)(int)) // function pointer\n{\n    for (auto i : v)\n    {\n        f(i);\n    }\n}\n\nvoid printVal(int i)\n{\n    cout &lt;&lt; \"value is: \" &lt;&lt; i &lt;&lt; endl;\n}\n\nint main()\n{\n    vector&lt;int&gt; v = {1, 2, 3, 4, 5};\n    forEach(v, printVal);\n    return 0;\n}\n</code></pre>"},{"location":"00-basics/02-functions/02-function-pointers/#lambda-functions","title":"Lambda functions","text":"<ul> <li>If all you need to do is to pass a function to another function, then instead of creating a function in global space, you can create a function in the local scope.</li> <li>This anonymous function (a function without a name) is called <code>lambda function</code>.</li> <li><code>lambda functions</code> can <code>capture values from surrounding scope</code>.</li> </ul> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\nusing namespace std;\n\nvoid forEach(vector&lt;int&gt; v, void (*f)(int))\n{\n    for (auto i : v)\n    {\n        f(i);\n    }\n}\n\nint main()\n{\n    vector&lt;int&gt; v = {1, 2, 3, 4, 5};\n    forEach(v, [](int i) {\n        cout &lt;&lt; \"value is: \" &lt;&lt; i &lt;&lt; endl;\n    });\n    return 0;\n}\n</code></pre>"},{"location":"00-basics/02-functions/03-function-variable/","title":"Function Variable","text":"<ul> <li>Sometimes, you need to store a function in a variable that you can call later.</li> <li>For example, DeepTensor (a minimal pytorch like autograd framework)'s Value object requires <code>backward_</code> variable, that stores the function to be called when <code>value::backward()</code> is called.</li> </ul>"},{"location":"00-basics/02-functions/03-function-variable/#older-way-before-c11","title":"Older way (before C++11)","text":"<ul> <li>Before C++11, we used to use <code>function-pointers</code>.</li> </ul> <pre><code>#include &lt;iostream&gt;\n\nint sum(int a, int b){\n    return a+b;\n}\n\nint main(){\n    int(*fn)(int, int) = nullptr;\n    if(!fn){\n        std::cout&lt;&lt;\"fn is null.\\n\";\n    }\n\n    fn = sum;\n    std::cout&lt;&lt;\"calling fn: \"&lt;&lt;fn(2,3)&lt;&lt;\"\\n\";\n\n}\n</code></pre>"},{"location":"00-basics/02-functions/03-function-variable/#after-c11","title":"After C++11","text":"<ul> <li>From C++11 you can use std::function to store functions.</li> </ul> <pre><code>std::function&lt;return_type(parameter_type1, parameter_type2, ...)&gt;\n</code></pre> <pre><code>#include &lt;iostream&gt;\n\nint sum(int a, int b){\n    return a+b;\n}\n\nint main(){\n    std::function&lt;int(int, int)&gt; fn = nullptr;\n    if(!fn){\n        std::cout&lt;&lt;\"fn is null.\\n\";\n    }\n\n    fn = sum;\n    std::cout&lt;&lt;\"calling fn: \"&lt;&lt;fn(2,3)&lt;&lt;\"\\n\";\n\n}\n</code></pre>"},{"location":"00-basics/02-functions/04-lambda-functions/","title":"Lambda functions (<code>closure</code>)","text":"<ul> <li>C++ 11 introduced lambda expressions</li> <li>allow inline functions which can be used for short snippets of code that are not going to be reused and therefore do not require a name.</li> </ul> <pre><code>[ capture clause ] (parameters) -&gt; return-type  \n{   \n   definition of method   \n} \n</code></pre> <ul> <li> <p>Generally, the <code>return-type in lambda expressions is evaluated by the compiler itself</code> and we don\u2019t need to specify it explicitly. Also the <code>-&gt; return-type part can be ignored</code>.</p> </li> <li> <p>However, in some complex cases e.g. conditional statements, the compiler can\u2019t determine the return type and explicit specification is required.</p> </li> </ul>"},{"location":"00-basics/02-functions/04-lambda-functions/#capture-clause","title":"Capture clause","text":"<ul> <li>A lambda expression can have more power than an ordinary function by having access to variables from the enclosing scope.</li> </ul> <p>Capture variables for lambda functions</p> <ul> <li>Capture by reference</li> <li>Capture by value</li> <li>Capture by both (mixed capture)</li> </ul> <p>Syntax used for capturing variables</p> <ul> <li>[&amp;] : capture all external variables by reference</li> <li>[=] : capture all external variables by value</li> <li>[a, &amp;b] : capture a by value and b by reference</li> <li>[=, &amp;b] : capture all variables by value, and b by reference</li> <li>[] : don't capture any variable</li> <li>[this, ...] : Capture raw pointer this (DANGEROUS!). Can't prevent <code>use after deletion bug</code></li> <li>[self = shared_from_this(), ...] : Capture shared_ptr to this (SAFE!)</li> </ul> <p><code>this</code> v/s <code>shared_from_this()</code></p> <p>TL;DR:</p> <ul> <li>Use <code>[this]</code> only if you're sure the object won't be deleted.</li> <li>Use <code>[self = shared_from_this()]</code> to prevent dangling pointers in async code. \ud83d\ude80</li> </ul>"},{"location":"00-basics/02-functions/04-lambda-functions/#code","title":"Code","text":"<ul> <li>map function: lambda function to square all numbers of the array and return new array.</li> </ul> <pre><code>#include &lt;functional&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint sum(int a, int b) { return a + b; }\n\nstd::vector&lt;int&gt; forEach(std::vector&lt;int&gt; v, std::function&lt;int(int)&gt; fn) {\n  std::vector&lt;int&gt; v_sq;\n  for (auto &amp;e : v) {\n    v_sq.push_back(fn(e));\n  }\n  return v_sq;\n}\n\nvoid printVec(std::vector&lt;int&gt; &amp;v) {\n  for (auto &amp;e : v) {\n    std::cout &lt;&lt; e &lt;&lt; \", \";\n  }\n  std::cout &lt;&lt; \"\\n\";\n}\nint main() {\n  std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};\n  std::vector&lt;int&gt; v_sq = forEach(v, [](int i) { return i * i; });\n  printVec(v);\n  printVec(v_sq);\n}\n</code></pre>"},{"location":"00-basics/02-functions/04-lambda-functions/#code-for-capturing-value","title":"Code for capturing value","text":"<pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nvoid printVec(std::vector&lt;int&gt; &amp;v) {\n  for (auto &amp;e : v) {\n    std::cout &lt;&lt; e &lt;&lt; \", \";\n  }\n  std::cout &lt;&lt; \"\\n\";\n}\n\nint main() {\n  std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};\n  auto fn = [&amp;v]() {\n    // captured vector by reference\n    for (auto &amp;e : v) {\n      e = e * e;\n    }\n  };\n\n  printVec(v);\n  std::cout &lt;&lt; \"calling lambda fn\\n\";\n  fn();\n  std::cout &lt;&lt; \"updated vector: \\n\";\n  printVec(v);\n}\n</code></pre>"},{"location":"01-cmake/01-introduction/","title":"Introduction to CMake","text":"<ul> <li>We used to write makefiles to build our projects. But, for large projects, it becomes difficult to maintain and manage.</li> <li>CMake is a build system generator. It is used to generate build files for various build systems.</li> <li>CMake is a cross-platform build system.</li> <li>We write <code>CMakeLists.txt</code> file to configure the build system.</li> <li>To build a project, we need to run <code>cmake</code> command.</li> </ul> <p>CMake must know!</p> <ul> <li>CMake is not a build system.</li> <li>CMake is a build-system generator. It generates the build system files.</li> </ul> <p>What are build-system?</p> <ul> <li>A file that contains code for how to link different files, compile them, etc for the current os/hardware.</li> <li>e.g., Makefiles, Ninja, etc.</li> </ul>"},{"location":"01-cmake/01-introduction/#a-simple-cpp-file","title":"A simple cpp file","text":"<pre><code>// main.cpp\n#include &lt;iostream&gt;\n\nint main() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n    return 0;\n}\n</code></pre>"},{"location":"01-cmake/01-introduction/#cmakeliststxt-file","title":"CMakeLists.txt file","text":"<pre><code># CMakeLists.txt\ncmake_minimum_required(VERSION 3.21)\nproject(cmake-example VERSION 1.0.0 LANGUAGES CXX) // project name, version, languages\n\nadd_executable(cpp-codes main.cpp) // executableName,  fileName\n</code></pre> <ul> <li>We use <code>CXX</code> for C++ files. Since, '+' will be considered as a operator in CMake.</li> </ul>"},{"location":"01-cmake/01-introduction/#build-the-project","title":"Build the project","text":"<pre><code>mkdir build &amp;&amp; cd build # to keep the root directory clean\ncmake .. # specifying the path of the CMakeLists.txt file\n# the above command will generate the build files\ncmake --build . # to build the project\n</code></pre>"},{"location":"01-cmake/01-introduction/#run-executable","title":"Run executable","text":"<pre><code>./cpp-codes # to run the executable\n</code></pre>"},{"location":"01-cmake/01-introduction/#some-important-flags","title":"Some important flags \ud83c\uddec\ud83c\udde7","text":"<ul> <li><code>-S</code> specify the CMakeLists.txt file path</li> <li><code>-B</code> specify the build directory</li> <li><code>-G</code> specify the build generator name (makefile, ninja, etc.)</li> </ul> <pre><code>mkdir build &amp;&amp; cd build\ncmake -S .. -B . # option 1\ncmake .. # option 2 (builds in the current directory by default)\n\n\n# =================\n\n# generate the build file for make/ninja\n# run `cmake --help` for more info\n\ncmake .. -G \"Unix Makefiles\"\ncmake .. -G \"Ninja\"\n</code></pre>"},{"location":"01-cmake/02-using-a-library/","title":"Using a Library in CMake","text":"<p>Basic idea</p> <p>We will be required to compile the library, and then link it with our executable.</p>"},{"location":"01-cmake/02-using-a-library/#directory-structure","title":"Directory structure","text":"<pre><code>|-- CMakeLists.txt\n|-- main.cpp\n|-- lib.h\n|-- lib.cpp\n</code></pre>"},{"location":"01-cmake/02-using-a-library/#libh-file","title":"<code>lib.h</code> file","text":"<pre><code># pragma once // to avoid multiple inclusion\nvoid printHelloWorld();\n</code></pre>"},{"location":"01-cmake/02-using-a-library/#libcpp-file","title":"<code>lib.cpp</code> file","text":"<pre><code>#include \"lib.h\"\n#include &lt;iostream&gt;\n\nvoid printHelloWorld() {\n    std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"01-cmake/02-using-a-library/#maincpp-file","title":"<code>main.cpp</code> file","text":"<pre><code>#include \"lib.h\"\n\nint main() {\n    printHelloWorld();\n    return 0;\n}\n</code></pre>"},{"location":"01-cmake/02-using-a-library/#cmakeliststxt-file","title":"<code>CMakeLists.txt</code> file","text":"<pre><code>cmake_minimum_required(VERSION 3.21)\nproject(cmake-example VERSION 1.0.0 LANGUAGES CXX)\n\nset(CMAKE_CXX_STANDARD          17) # set c++ standard to 17\nset(CMAKE_CXX_STANDARD_REQUIRED ON) # without cpp 17, compiler will give error\nset(CMAKE_CXX_EXTENSIONS        OFF) # it's fine to use c++ 17 without extensions (like, bits/stdc++.h)\n\nadd_library(myLib STATIC lib.cpp) # libraryName, STATIC/SHARED, fileName\n\nadd_executable(myExecutable main.cpp) # executableName,  fileName\n\ntarget_link_libraries(myExecutable PUBLIC myLib) # targetName, PUBLIC/PRIVATE/INTERFACE, libraryName\n</code></pre>"},{"location":"01-cmake/02-using-a-library/#compiling-and-running","title":"Compiling and running","text":"<pre><code>mkdir build &amp;&amp; cd build\ncmake ..\ncmake --build .\n./myExecutable\n</code></pre> <ul> <li>To build only library</li> </ul> <pre><code>cmake --build . --target myLib\n</code></pre> <ul> <li>When we build only library, executable will not be built.</li> <li>But, when we build executable, library will be built, as it is a dependency (linked).</li> </ul>"},{"location":"01-cmake/02-using-a-library/#following-a-directory-structure","title":"Following a directory structure","text":"<pre><code>|-- src/\n|   |-- CMakeLists.txt\n|   |-- main.cpp\n|-- lib/\n|   |-- CMakeLists.txt\n|   |-- mylib1/\n|       |-- CMakeLists.txt\n|       |-- lib.cpp\n|-- include/\n|   |-- lib.h\n|-- CMakeLists.txt\n</code></pre> <p>Note</p> <ul> <li> <p>Keeping <code>lib.h</code> file in <code>include</code> directory is a good practice if you want your users to be able to use your library.</p> </li> <li> <p>If you want to hide the implementation details of your library, you can put it along with the actual implementation files in <code>lib</code> directory.</p> </li> </ul> <ul> <li>Top level <code>CMakeLists.txt</code> file will be responsible for building the entire project.</li> <li>It will call <code>CMakeLists.txt</code> file in <code>src</code> and <code>lib</code> directories.</li> <li>Variables and functions defined in <code>CMakeLists.txt</code> file in <code>src</code> and <code>lib</code> directories will be available in the top level <code>CMakeLists.txt</code> file.</li> </ul>"},{"location":"01-cmake/02-using-a-library/#cmake-builtin-functions","title":"CMake builtin functions","text":"<ul> <li><code>add_subdirectory</code> function is used to call <code>CMakeLists.txt</code> file in <code>src</code> and <code>lib</code> directories.</li> <li><code>include_directories</code> function is used to add include directories to the project.</li> <li><code>target_include_directories</code> function is used to add include directories to a specific target.</li> <li><code>target_link_libraries</code> function is used to link a specific target with a library.</li> <li><code>add_library</code> function is used to create a library. And it can be <code>STATIC</code> or <code>SHARED</code>.</li> <li><code>add_executable</code> function is used to create an executable.</li> </ul>"},{"location":"01-cmake/02-using-a-library/#cmakeliststxt-file-in-each-directory","title":"CMakeLists.txt file in each directory","text":"<ul> <li><code>root level</code></li> </ul> <pre><code>cmake_minimum_required(VERSION 3.21)\nproject(cmake-example VERSION 1.0.0 LANGUAGES CXX)\n\nset(EXECUTABLE_NAME myExecutable)\nset(LIBRARY_NAME myLib)\n\nadd_subdirectory(lib) // first build the library\nadd_subdirectory(include) // then link the library with the include directory\n\nadd_subdirectory(src) // build executable, and link it with the library\n</code></pre> <ul> <li><code>lib</code> directory</li> </ul> <pre><code>add_subdirectory(mylib1) # call CMakeLists.txt file in mylib1 directory\n</code></pre> <ul> <li><code>lib/mylib1</code> directory</li> </ul> <pre><code>add_library(${LIBRARY_NAME} STATIC lib.cpp)\n</code></pre> <ul> <li><code>include</code> directory</li> </ul> <pre><code>add_subdirectory(mylib1) # call CMakeLists.txt file in mylib1 directory\n</code></pre> <ul> <li><code>include/mylib1</code> directory</li> </ul> <pre><code>target_include_directories(${LIBRARY_NAME} PUBLIC \"./\") # add include directory to the library\n</code></pre> <ul> <li><code>src</code> directory</li> </ul> <pre><code>include_directories(\"../include\") # add include directory to the executable\nadd_executable(${EXECUTABLE_NAME} main.cpp)\ntarget_link_libraries(${EXECUTABLE_NAME} PUBLIC ${LIBRARY_NAME})\n</code></pre>"},{"location":"01-cmake/02-using-a-library/#running-the-project","title":"Running the project","text":"<pre><code>mkdir build &amp;&amp; cd build\ncmake ..\ncmake --build .\n./myExecutable\n</code></pre>"},{"location":"01-cmake/03-variables-and-options/","title":"Variables and Options in CMake","text":""},{"location":"01-cmake/03-variables-and-options/#variables-options-in-cmake","title":"Variables &amp; Options in CMake","text":"<ul> <li>Variables are used to store values, so that they can be used later in the project.</li> <li>Variables are defined using the <code>set</code> command.</li> </ul> <pre><code>set(VARIABLE_NAME value) # variableName, value\n\n${VARIABLE_NAME} # reference to the variable\n\n\n# ---- options ----\noption(COMPILE_EXECUTABLE \"Whether to compile the executable\" ON)\n\nif (COMPILE_EXECUTABLE) # use option in conditional statements\n    add_subdirectory(app)\nelse()\n    message(STATUS \"Not compiling executable\")\nendif()\n</code></pre>"},{"location":"01-cmake/03-variables-and-options/#changing-the-value-of-a-variable-at-runtime","title":"Changing the value of a variable at runtime","text":"<ul> <li>We can use <code>-D{variableName}={value}</code> option to change the value of a variable at runtime.</li> </ul> <pre><code>cmake -DCOMPILE_EXECUTABLE=OFF ..\n</code></pre> <p>Note</p> <ul> <li>This feature is heavily used when we are building a library for release.</li> <li>We use <code>-DCMAKE_BUILD_TYPE=Release</code> option to change the value of <code>CMAKE_BUILD_TYPE</code> variable at runtime.</li> <li>This will let CMAKE know that we will relase the library, so perform maximum optimizations.</li> </ul> <pre><code>cd debug\ncmake -DCMAKE_BUILD_TYPE=Debug ..\ncmake --build .\n\n# ---- release build ----\n\ncd ../release\ncmake -DCMAKE_BUILD_TYPE=Release ..\ncmake --build .\n</code></pre>"},{"location":"01-cmake/03-variables-and-options/#contionals-statements","title":"Contionals statements","text":"<pre><code>if(&lt;condition&gt;)\n  &lt;commands&gt;\nelseif(&lt;condition&gt;) # optional block, can be repeated\n  &lt;commands&gt;\nelse()              # optional block\n  &lt;commands&gt;\nendif()\n</code></pre>"},{"location":"01-cmake/03-variables-and-options/#some-commonly-used-standard-variables","title":"Some commonly used standard variables","text":"<pre><code>set(CMAKE_CXX_STANDARD          17) # set c++ standard to 17\nset(CMAKE_CXX_STANDARD_REQUIRED ON) # without cpp 17, compiler will give error\nset(CMAKE_CXX_EXTENSIONS        OFF) # it's fine to use c++ 17 without extensions (like, bits/stdc++.h)\n</code></pre> <p>Project-Related Variables:</p> <ul> <li><code>CMAKE_CURRENT_SOURCE_DIR</code>: The directory containing the current CMakeLists.txt file.</li> <li><code>CMAKE_CURRENT_BINARY_DIR</code>: The directory where the build system files (e.g., Makefiles) are generated.</li> <li><code>PROJECT_SOURCE_DIR</code>: The root directory of the project.</li> <li><code>PROJECT_BINARY_DIR</code>: The root directory of the build system files.</li> <li><code>PROJECT_NAME</code>: The name of the project, as specified in the <code>project()</code> command.</li> <li><code>CMAKE_BUILD_TYPE</code>: The build type (e.g., Debug, Release, MinSizeRel, RelWithDebInfo).</li> </ul> <p>Compiler and Platform Variables:</p> <ul> <li><code>CMAKE_CXX_COMPILER</code>: The C++ compiler.</li> <li><code>CMAKE_C_COMPILER</code>: The C compiler.</li> <li><code>CMAKE_SYSTEM_NAME</code>: The name of the operating system (e.g., Linux, Windows, macOS).</li> <li><code>CMAKE_SYSTEM_PROCESSOR</code>: The processor architecture (e.g., x86_64, arm).</li> </ul> <p>Build System Variables:</p> <ul> <li><code>CMAKE_MAKE_PROGRAM</code>: The path to the Make program.</li> <li><code>CMAKE_NINJA_EXECUTABLE</code>: The path to the Ninja build system.</li> <li><code>CMAKE_GENERATOR</code>: The name of the build system generator (e.g., Unix Makefiles, Visual Studio).</li> </ul> <p>Other Useful Variables:</p> <ul> <li><code>CMAKE_INSTALL_PREFIX</code>: The installation prefix for the project.</li> <li><code>CMAKE_INCLUDE_PATH</code>: The include path for header files.</li> <li><code>CMAKE_LIBRARY_PATH</code>: The library search path.</li> </ul>"},{"location":"01-cmake/04-cache-in-cmake/","title":"Cache in CMake","text":""},{"location":"01-cmake/04-cache-in-cmake/#cmake-cache-a-quick-overview","title":"CMake Cache: A Quick Overview","text":"<ul> <li>CMake uses a cache system to store configuration options and variables.</li> <li>This cache is typically stored in a file named <code>CMakeCache.txt</code> in the build directory.</li> <li>When you configure a CMake project, CMake reads the cache file to determine the values of various options and variables.</li> </ul>"},{"location":"01-cmake/04-cache-in-cmake/#modifying-cache-values-for-faster-builds","title":"Modifying Cache Values for Faster Builds","text":"<p>One of the advantages of using the CMake cache is that you can modify the cache values to avoid reconfiguring the entire project. This can significantly reduce build times, especially for large projects.</p> <p>Here's a common scenario:</p> <ol> <li>Modify a Cache Variable:</li> <li>Open the <code>CMakeCache.txt</code> file in the build directory.</li> <li>Find the variable you want to modify and change its value.</li> <li> <p>Save the file.</p> </li> <li> <p>Build the Project:</p> </li> <li>Run the build command (e.g., <code>cmake --build .</code>)</li> </ol> <p>CMake will use the modified cache values to build the project, skipping unnecessary steps like re-generating the build system files. This can lead to significant time savings, particularly when making minor changes to build options or configurations.</p>"},{"location":"01-cmake/04-cache-in-cmake/#vscode-cmake-cache-editor","title":"VSCode CMake cache editor","text":"<ul> <li>Since <code>CMakeCache.txt</code> can become quite large, and some keys might also be modified.</li> <li>So, we can use <code>CMake Cache Editor</code> extension in VSCode.</li> <li>Just run <code>cmd + shift + p</code> and find <code>CMake Cache Editor (UI)</code>.</li> </ul> <p>Important Considerations</p> <ul> <li>Cache Invalidation: Be aware that certain changes to the source code or CMake configuration files might invalidate the cache, requiring a full reconfiguration.</li> <li>Complex Projects: For complex projects with many dependencies and custom build systems, the benefits of modifying cache values might be less pronounced.</li> <li>Best Practices: While modifying the cache can be a useful technique, it's generally recommended to use CMake's built-in mechanisms for configuring and building projects. This ensures consistency and reproducibility.</li> </ul> <p>By understanding the CMake cache and its role in the build process, you can optimize your build times and improve your development workflow.</p>"},{"location":"01-cmake/05-configure-files/","title":"Configure Files in CMake","text":"<ul> <li><code>configure files</code> is used to copy file from one directory to another and modify some of its contents.</li> </ul>"},{"location":"01-cmake/05-configure-files/#usecase","title":"UseCase","text":"<ul> <li>Let's say we are working on a CLI app, and when user runs <code>--version</code>, we want to print the version of the app.</li> <li>Our CMakeLists.txt file also needs to know the version of the app.</li> <li>So, either we can specify the version at each place, or we can just specify it once, and other places can use it.</li> </ul>"},{"location":"01-cmake/05-configure-files/#idea","title":"Idea","text":"<ul> <li>The main idea is, we will specify the values of variables in the <code>CMakeLists.txt</code> file.</li> <li>Then, we will create a template type file (<code>filename.hpp.in</code>), that will have variables and the values will be replaced with the actual values when we run <code>cmake</code>.</li> <li>This template file will be used by other cpp files, to print the version of the app.</li> </ul>"},{"location":"01-cmake/05-configure-files/#directory-structure","title":"Directory structure","text":"<pre><code>|-- CMakeLists.txt\n|-- configured/\n|   |-- CMakeLists.txt\n|   |-- config.hpp.in # template file\n|-- main.cpp\n</code></pre>"},{"location":"01-cmake/05-configure-files/#code","title":"Code","text":"<ul> <li><code>config.hpp.in</code> file</li> </ul> <pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n#include &lt;string_view&gt;\n\nstatic constexpr std::string_view project_name = \"@PROJECT_NAME@\";\nstatic constexpr std::string_view project_version = \"@PROJECT_VERSION@\";\n\nstatic constexpr std::int32_t project_version_major{@PROJECT_VERSION_MAJOR@};\nstatic constexpr std::int32_t project_version_minor{@PROJECT_VERSION_MINOR@};\nstatic constexpr std::int32_t project_version_patch{@PROJECT_VERSION_PATCH@};\n</code></pre> <ul> <li><code>configured/CMakeLists.txt</code> file</li> </ul> <pre><code># Note: If you open the config.hhp.in file in VSCode it is normal that the code has red squiggly lines.\n# VSCode think its a normal header file, which it isnt.\n# But thats okay.\nconfigure_file(\n    \"config.hpp.in\" # input file\n    \"${CMAKE_BINARY_DIR}/configured_files/include/config.hpp\" # output file\n    ESCAPE_QUOTES\n)\n</code></pre> <ul> <li><code>CMakeLists.txt</code> file</li> </ul> <pre><code>cmake_minimum_required(VERSION 3.22)\n\nproject(CppProjectTemplate VERSION 1.0.0 LANGUAGES C CXX)\n\nset(CMAKE_CXX_STANDARD          17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\nset(CMAKE_CXX_EXTENSIONS        OFF)\n\nset(LIBRARY_NAME Library)\nset(EXECUTABLE_NAME Executable)\n\nadd_subdirectory(configured)\n\nadd_executable(${EXECUTABLE_NAME} main.cpp)\n\ntarget_include_directories(\n    ${EXECUTABLE_NAME}\n    PRIVATE\n    \"${CMAKE_BINARY_DIR}/configured_files/include\"\n) # include directory with target (executable)\n</code></pre>"},{"location":"01-cmake/05-configure-files/#using-the-configured-files-in-cpp-files","title":"Using the configured files in cpp files","text":"<pre><code>#include &lt;iostream&gt;\n\n#include \"config.hpp\"\n\nint main()\n{\n    std::cout &lt;&lt; project_name &lt;&lt; '\\n';\n    std::cout &lt;&lt; project_version &lt;&lt; '\\n';\n\n    return 0;\n}\n</code></pre>"},{"location":"01-cmake/06-some-more-info/","title":"CMake Notes: <code>function</code>, <code>include</code>, and <code>FetchContent</code>","text":""},{"location":"01-cmake/06-some-more-info/#1-function","title":"1. <code>function</code>","text":""},{"location":"01-cmake/06-some-more-info/#purpose","title":"Purpose:","text":"<p>Defines reusable blocks of CMake code. It creates a local scope, meaning variables defined inside a function won't affect the global scope unless explicitly modified.</p>"},{"location":"01-cmake/06-some-more-info/#syntax","title":"Syntax:","text":"<pre><code>function(FunctionName arg1 arg2)\n    # Body of the function\n    message(\"Argument 1: ${arg1}\")\n    message(\"Argument 2: ${arg2}\")\nendfunction()\n</code></pre>"},{"location":"01-cmake/06-some-more-info/#example","title":"Example:","text":"<pre><code>function(print_message msg)\n    message(\"Message: ${msg}\")\nendfunction()\n\nprint_message(\"Hello, CMake!\")\n</code></pre> <p>Output: <pre><code>Message: Hello, CMake!\n</code></pre></p>"},{"location":"01-cmake/06-some-more-info/#2-include","title":"2. <code>include</code>","text":""},{"location":"01-cmake/06-some-more-info/#purpose_1","title":"Purpose:","text":"<p>Includes another CMake script file to reuse its logic. Useful for modularizing CMake code.</p>"},{"location":"01-cmake/06-some-more-info/#syntax_1","title":"Syntax:","text":"<pre><code>include(FileName.cmake [OPTIONAL] [RESULT_VARIABLE var])\n</code></pre>"},{"location":"01-cmake/06-some-more-info/#example_1","title":"Example:","text":"<p>Main CMakeLists.txt <pre><code>include(helper.cmake)\nhello_world()\n</code></pre></p> <p>helper.cmake <pre><code>function(hello_world)\n    message(\"Hello from helper.cmake!\")\nendfunction()\n</code></pre></p> <p>Output: <pre><code>Hello from helper.cmake!\n</code></pre></p>"},{"location":"01-cmake/06-some-more-info/#3-fetchcontent","title":"3. <code>FetchContent</code>","text":""},{"location":"01-cmake/06-some-more-info/#purpose_2","title":"Purpose:","text":"<p>Fetches and integrates external dependencies directly into the build process.</p>"},{"location":"01-cmake/06-some-more-info/#syntax_2","title":"Syntax:","text":"<pre><code>include(FetchContent)\nFetchContent_Declare(\n    &lt;Name&gt;\n    GIT_REPOSITORY &lt;url&gt;\n    GIT_TAG &lt;commit/tag/branch&gt;\n)\nFetchContent_MakeAvailable(&lt;Name&gt;)\n</code></pre>"},{"location":"01-cmake/06-some-more-info/#example_2","title":"Example:","text":"<pre><code>include(FetchContent)\n\nFetchContent_Declare(\n    json\n    GIT_REPOSITORY https://github.com/nlohmann/json.git\n    GIT_TAG v3.11.2\n)\n\nFetchContent_MakeAvailable(json)\n\nadd_executable(my_app main.cpp)\ntarget_link_libraries(my_app PRIVATE nlohmann_json::nlohmann_json)\n</code></pre> <p>This fetches the <code>nlohmann/json</code> library and links it to <code>my_app</code>.</p>"},{"location":"01-cmake/06-some-more-info/#summary-table","title":"Summary Table:","text":"Feature Purpose Key Point <code>function</code> Defines reusable logic in local scope Use for modular code blocks <code>include</code> Includes another CMake script Helps in splitting CMake logic <code>FetchContent</code> Fetches external dependencies dynamically Simplifies dependency management"},{"location":"02-bavel/01-intro/","title":"Introduction to Bazel","text":""},{"location":"02-bavel/01-intro/#what-is-bazel","title":"What is Bazel?","text":"<p>Bazel is an open-source build and test tool from Google, designed to handle large-scale projects efficiently. It supports multiple programming languages (e.g., Python, Java, C++, Go) and offers fast, reliable, and reproducible builds. Bazel excels in managing dependencies and parallelizing builds, making it a popular choice for complex, multi-language systems.</p>"},{"location":"02-bavel/01-intro/#why-use-bazel","title":"Why Use Bazel?","text":"<ol> <li> <p>Speed:</p> <ul> <li>Bazel optimizes build times by caching outputs and reusing them when inputs haven\u2019t changed.</li> <li>It performs parallel builds, leveraging all available CPU cores.</li> </ul> </li> <li> <p>Reproducibility:</p> <ul> <li>Builds are deterministic; the same inputs always produce the same outputs, regardless of the environment.</li> </ul> </li> <li> <p>Language Agnostic:</p> <ul> <li>Supports multiple languages like C++, Java, Python, Go, and more within the same project.</li> </ul> </li> <li> <p>Scalability:</p> <ul> <li>Handles large, multi-language codebases with ease.</li> </ul> </li> <li> <p>Cross-Platform:</p> <ul> <li>Works seamlessly across Windows, macOS, and Linux.</li> </ul> </li> <li> <p>Dependency Management:</p> <ul> <li>Explicitly manages dependencies to ensure consistency and avoid unexpected conflicts.</li> </ul> </li> </ol>"},{"location":"02-bavel/01-intro/#basic-idea-behind-bazel","title":"Basic Idea Behind Bazel","text":"<ul> <li> <p>Declarative Build System:</p> <ul> <li>Bazel uses <code>BUILD</code> files to describe the components of your project and their dependencies.</li> <li>You define what to build (targets), not how to build it.</li> </ul> </li> <li> <p>Targets and Rules:</p> <ul> <li>Targets: Represent buildable outputs like binaries, libraries, or test executables.</li> <li>Rules: Define how to build targets (e.g., <code>cc_binary</code> for C++ binaries, <code>py_library</code> for Python libraries).</li> </ul> </li> <li> <p>WORKSPACE:</p> <ul> <li>The root configuration file, which defines external dependencies and the project\u2019s workspace.</li> </ul> </li> <li> <p>Caching:</p> <ul> <li>Bazel avoids rebuilding files if their inputs haven\u2019t changed, ensuring faster incremental builds.</li> </ul> </li> </ul>"},{"location":"02-bavel/01-intro/#typical-workflow-with-bazel","title":"Typical Workflow with Bazel","text":"<ul> <li> <p>Set Up Workspace:</p> <ul> <li>Create a <code>WORKSPACE</code> file in the root of your project to define external dependencies and the workspace.</li> </ul> </li> <li> <p>Write BUILD Files:</p> <ul> <li>Each directory in the project contains a <code>BUILD</code> file that specifies the targets and their dependencies.</li> <li>Example of a <code>BUILD</code> file:   <pre><code>cc_binary(\n    name = \"hello_world\",\n    srcs = [\"hello_world.cpp\"],\n    deps = [\"@some_library\"],\n)\n</code></pre></li> </ul> </li> <li> <p>Build Targets:</p> <ul> <li>Use the Bazel CLI to build a target:    <pre><code>bazel build //path/to:target\n</code></pre></li> </ul> </li> <li> <p>Run Tests:</p> <ul> <li>Run tests defined in the <code>BUILD</code> file:    <pre><code>bazel test //path/to:test_target\n</code></pre></li> </ul> </li> <li> <p>Run the Binary:</p> <ul> <li>Execute a binary you just built:    <pre><code>bazel run //path/to:binary\n</code></pre></li> </ul> </li> <li> <p>Add External Dependencies:</p> <ul> <li>Use repository rules in the <code>WORKSPACE</code> file, like <code>http_archive</code>:    <pre><code>load(\"@bazel_tools//tools/build_defs/repo:http.bzl\", \"http_archive\")\n\nhttp_archive(\n    name = \"example_lib\",\n    urls = [\"https://example.com/library.tar.gz\"],\n    strip_prefix = \"library-1.0\",\n)\n</code></pre></li> </ul> </li> </ul>"},{"location":"02-bavel/01-intro/#summary","title":"Summary","text":"<p>Bazel provides a robust, scalable, and efficient build system for projects of all sizes. By understanding its core concepts\u2014<code>WORKSPACE</code>, <code>BUILD</code> files, rules, and targets\u2014you can manage dependencies, optimize builds, and ensure consistency across platforms. The workflow revolves around defining dependencies explicitly and using the CLI for building, testing, and running targets.</p>"},{"location":"polymorphism/01-dynamic-dispatch/","title":"Dynamic Dispatch in C++","text":"<ul> <li>Definition: Dynamic dispatch is a runtime mechanism that determines which implementation of a polymorphic function to invoke when a base class pointer or reference is used.</li> </ul>"},{"location":"polymorphism/01-dynamic-dispatch/#key-points","title":"Key Points","text":"<ol> <li>Polymorphism Requirement:  </li> <li>The base class must have at least one virtual function to enable dynamic dispatch.</li> <li> <p>Derived classes override the virtual function.</p> </li> <li> <p>Virtual Table (vtable):  </p> </li> <li>C++ uses a vtable (virtual table) to resolve function calls at runtime.</li> <li> <p>Each polymorphic class has a vtable, and each instance stores a pointer to its class's vtable.</p> </li> <li> <p>How It Works:</p> </li> <li> <p>When calling a virtual function via a base class pointer/reference, the vtable lookup determines which derived class's function to invoke.</p> </li> <li> <p>Usage:</p> </li> <li>Define virtual functions in the base class.</li> <li>Override these functions in derived classes.</li> </ol>"},{"location":"polymorphism/01-dynamic-dispatch/#example","title":"Example:","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n// Base class\nclass Animal {\npublic:\n    virtual void speak() const {\n        cout &lt;&lt; \"Animal speaks!\" &lt;&lt; endl;\n    }\n    virtual ~Animal() = default; // Virtual destructor for proper cleanup\n};\n\n// Derived classes\nclass Dog : public Animal {\npublic:\n    void speak() const override { // Override keyword for safety\n        cout &lt;&lt; \"Dog barks!\" &lt;&lt; endl;\n    }\n};\n\nclass Cat : public Animal {\npublic:\n    void speak() const override {\n        cout &lt;&lt; \"Cat meows!\" &lt;&lt; endl;\n    }\n};\n\n// Runtime polymorphism\nvoid makeAnimalSpeak(const Animal&amp; animal) {\n    animal.speak(); // Resolved at runtime\n}\n\nint main() {\n    Dog dog;\n    Cat cat;\n\n    makeAnimalSpeak(dog); // Output: Dog barks!\n    makeAnimalSpeak(cat); // Output: Cat meows!\n    return 0;\n}\n</code></pre>"},{"location":"polymorphism/01-dynamic-dispatch/#when-to-use","title":"When to Use:","text":"<ul> <li>When you need runtime polymorphism, such as in plugin systems, AST evaluation, game engines, or any scenario requiring behavior selection based on object type at runtime.</li> </ul>"},{"location":"polymorphism/01-dynamic-dispatch/#best-practices","title":"Best Practices:","text":"<ul> <li>Always use <code>override</code> keyword to ensure correct function overriding.</li> <li>Prefer <code>dynamic_cast</code> when you need safe downcasting.</li> <li>Use virtual destructors in base classes to prevent resource leaks.</li> </ul>"},{"location":"polymorphism/01-dynamic-dispatch/#my-code","title":"My code","text":"<pre><code>llvm::Value* CodeGen::codegen(const ast::ExprAST&amp; exprAst) {\n    enum ExprAstType {\n        NumberExpr,\n        VariableExpr,\n        BinaryExpr,\n        CallExpr,\n        Invalid,\n    };\n\n    ExprAstType e = Invalid;\n    if (typeid(exprAst) == typeid(ast::BinaryExprAST)) e = BinaryExpr;\n    else if (typeid(exprAst) == typeid(ast::NumberExprAST)) e = NumberExpr;\n    else if (typeid(exprAst) == typeid(ast::VariableExprAST)) e = VariableExpr;\n    else if (typeid(exprAst) == typeid(ast::CallExprAST)) e = CallExpr;\n\n    switch (e) {\n        default:\n            return nullptr;\n        case NumberExpr: {\n            // Dynamic cast to derived class\n            const auto* numExpr = dynamic_cast&lt;const ast::NumberExprAST*&gt;(&amp;exprAst);\n            if (numExpr) return codegen(*numExpr);\n            break;\n        }\n        case BinaryExpr: {\n            const auto* binExpr = dynamic_cast&lt;const ast::BinaryExprAST*&gt;(&amp;exprAst);\n            if (binExpr) return codegen(*binExpr);\n            break;\n        }\n        case VariableExpr: {\n            const auto* varExpr = dynamic_cast&lt;const ast::VariableExprAST*&gt;(&amp;exprAst);\n            if (varExpr) return codegen(*varExpr);\n            break;\n        }\n        case CallExpr: {\n            const auto* callExpr = dynamic_cast&lt;const ast::CallExprAST*&gt;(&amp;exprAst);\n            if (callExpr) return codegen(*callExpr);\n            break;\n        }\n    }\n\n    return nullptr;\n}\n</code></pre>"},{"location":"polymorphism/02-double-dispatch/","title":"Double Dispatch in C++","text":"<ul> <li>Definition: Double dispatch is a design pattern that allows a function to call another function based on the runtime types of two different objects. It\u2019s often used to handle operations involving multiple object types in a type-safe and flexible way.</li> </ul>"},{"location":"polymorphism/02-double-dispatch/#key-points","title":"Key Points","text":"<ol> <li> <p>Problem: In simple polymorphism, you can only dispatch based on the type of a single object. Double dispatch solves this by allowing you to decide on behavior based on the type of two objects involved in an operation.</p> </li> <li> <p>Common Use Case:  </p> </li> <li> <p>Common in systems where operations involve visiting different types of elements, such as an Abstract Syntax Tree (AST) in a compiler or a visitor pattern in OOP.</p> </li> <li> <p>How It Works:</p> </li> <li>A base method in an object calls another method on another object, passing the <code>this</code> pointer or reference to help decide which method to invoke on the second object.</li> <li> <p>This results in the second object invoking a method on the first object, ensuring the correct overload is chosen based on their runtime types.</p> </li> <li> <p>Example:</p> </li> <li>Imagine having a base <code>ExprAST</code> class with multiple derived types like <code>NumberExprAST</code>, <code>BinaryExprAST</code>, etc. Double dispatch helps in selecting the correct <code>codegen</code> function based on the type of the expression and the context of its use.</li> </ol>"},{"location":"polymorphism/02-double-dispatch/#example-code","title":"Example Code:","text":"<pre><code>#include &lt;iostream&gt;\nusing namespace std;\n\n// Base class for expressions\nclass ExprAST {\npublic:\n    virtual ~ExprAST() = default;\n    virtual void accept(class Visitor&amp; v) const = 0; // Pure virtual function for visitor pattern\n};\n\n// Derived class for NumberExpr\nclass NumberExprAST : public ExprAST {\npublic:\n    int value;\n    NumberExprAST(int val) : value(val) {}\n    void accept(Visitor&amp; v) const override; // Accept method for double dispatch\n};\n\n// Derived class for BinaryExpr\nclass BinaryExprAST : public ExprAST {\npublic:\n    ExprAST* left;\n    ExprAST* right;\n    BinaryExprAST(ExprAST* l, ExprAST* r) : left(l), right(r) {}\n    void accept(Visitor&amp; v) const override; // Accept method for double dispatch\n};\n\n// Visitor class that handles different types of expressions\nclass Visitor {\npublic:\n    virtual void visit(const NumberExprAST&amp; expr) const {\n        cout &lt;&lt; \"Visiting NumberExprAST with value: \" &lt;&lt; expr.value &lt;&lt; endl;\n    }\n    virtual void visit(const BinaryExprAST&amp; expr) const {\n        cout &lt;&lt; \"Visiting BinaryExprAST\" &lt;&lt; endl;\n        expr.left-&gt;accept(*this); // Dispatch to the left operand\n        expr.right-&gt;accept(*this); // Dispatch to the right operand\n    }\n};\n\n// Implementations of the accept methods\nvoid NumberExprAST::accept(Visitor&amp; v) const {\n    v.visit(*this);\n}\n\nvoid BinaryExprAST::accept(Visitor&amp; v) const {\n    v.visit(*this);\n}\n\nint main() {\n    NumberExprAST num(42);\n    BinaryExprAST bin(&amp;num, &amp;num);\n\n    Visitor visitor;\n    bin.accept(visitor); // Initiates double dispatch\n\n    return 0;\n}\n</code></pre>"},{"location":"polymorphism/02-double-dispatch/#benefits","title":"Benefits:","text":"<ul> <li>Flexibility: Can easily extend operations without altering the existing classes.</li> <li>Decoupling: Allows new operations to be added without modifying the base classes, adhering to the Open/Closed Principle.</li> </ul>"},{"location":"polymorphism/02-double-dispatch/#drawbacks","title":"Drawbacks:","text":"<ul> <li>Complexity: More intricate code due to the need for additional visitor classes.</li> <li>Performance: More dynamic dispatch calls can impact performance if not carefully managed.</li> </ul>"},{"location":"polymorphism/02-double-dispatch/#when-to-use","title":"When to Use:","text":"<ul> <li>When you need to implement operations that vary based on the types of multiple objects.</li> <li>When working with the Visitor Pattern to implement operations on elements of a composite structure, such as ASTs in a compiler.</li> </ul>"},{"location":"polymorphism/02-double-dispatch/#best-practices","title":"Best Practices:","text":"<ul> <li>Keep visitor classes clean and focused on handling specific behaviors.</li> <li>Ensure classes implementing double dispatch follow the Single Responsibility Principle to keep code manageable.</li> </ul>"},{"location":"polymorphism/02-double-dispatch/#my-code","title":"My code","text":"<pre><code>// Base class\nclass ExprAST {\npublic:\n    virtual ~ExprAST() = default;\n\n    // Virtual codegen function to be overridden by derived classes\n    virtual llvm::Value* codegen(CodeGen&amp; codegenObj) const = 0;\n};\n\n// Derived class example\nclass NumberExprAST : public ExprAST {\npublic:\n    llvm::Value* codegen(CodeGen&amp; codegenObj) const override {\n        return codegenObj.codegen(*this);\n    }\n};\n\n// CodeGen implementation\nllvm::Value* CodeGen::codegen(const ast::ExprAST&amp; exprAst) {\n    // Double dispatch: calls the correct codegen implementation\n    return exprAst.codegen(*this);\n}\n\n// Specialized codegen for NumberExprAST\nllvm::Value* CodeGen::codegen(const ast::NumberExprAST&amp; numExpr) {\n    // Handle NumberExprAST-specific logic here\n    return ...; // Generate LLVM IR\n}\n</code></pre>"}]}